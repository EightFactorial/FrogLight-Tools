use std::{cmp::Ordering, collections::HashSet, path::Path};

use convert_case::{Case, Casing};
use froglight_dependency::{
    container::DependencyContainer, dependency::mojang::VersionManifest, version::Version,
};

use crate::{
    module::{
        packet::{codecs::NetworkPackets, NetworkCodecs, VersionCodecs},
        Packets,
    },
    ToolConfig,
};

impl Packets {
    const MODULE_TEMPLATE: &str = r#"//! Packets for [`{VERSION}`]
//!
//! This file is auto-generated. Disable this by adding an `@manual` tag.
//!
//! @generated by {COMMIT_HASH}

#[cfg(feature = "{FEATURE}")]
use froglight_common::version::{VERSION};

#[cfg(feature = "{FEATURE}")]
use crate::state::{Config, Handshake, Login, Play, Status, ValidState};

pub mod config;
pub mod handshake;
pub mod login;
pub mod play;
pub mod status;

#[cfg(feature = "{FEATURE}")]
impl ValidState<Config> for {VERSION} {
    type Clientbound = config::ClientboundConfigPackets;
    type Serverbound = config::ServerboundConfigPackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Handshake> for {VERSION} {
    type Clientbound = handshake::ClientboundHandshakePackets;
    type Serverbound = handshake::ServerboundHandshakePackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Login> for {VERSION} {
    type Clientbound = login::ClientboundLoginPackets;
    type Serverbound = login::ServerboundLoginPackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Play> for {VERSION} {
    type Clientbound = play::ClientboundPlayPackets;
    type Serverbound = play::ServerboundPlayPackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Status> for {VERSION} {
    type Clientbound = status::ClientboundStatusPackets;
    type Serverbound = status::ServerboundStatusPackets;
}

#[cfg(feature = "{FEATURE}")]
pub mod prelude {
    //! Re-exports of all packet types.

    pub use froglight_common::version::{VERSION};

    pub use super::{config::*, handshake::*, login::*, play::*, status::*};
}
"#;

    /// Generate a `mod.rs` file for the given version in the specified folder.
    pub(super) async fn generate_version_module(
        version: &Version,
        path: &Path,
    ) -> anyhow::Result<()> {
        let version = format!("V{}", version.to_long_string().replace('.', "_"));
        let feature = version.to_lowercase();

        let mod_path = path.join("mod.rs");
        // Skip module generation if the file already exists and contains `@manual`
        if let Ok(existing) = tokio::fs::read_to_string(&mod_path).await {
            if existing.contains("@manual @generated") {
                return Ok(());
            }
        }

        // Create the directory if it does not exist
        if !tokio::fs::try_exists(&path).await? {
            tokio::fs::create_dir_all(&path).await?;
        }

        tracing::debug!("Packets: Generating \"{}\"", mod_path.display());
        let contents = Self::MODULE_TEMPLATE.replace("{VERSION}", &version);
        let contents = contents.replace("{FEATURE}", &feature);

        super::write_formatted(&contents, &mod_path).await
    }

    const INHERITED_TEMPLATE: &str = r#"//! Packets for [`{STATE}`](crate::state::{STATE})
//!
//! This file is auto-generated. Disable this by adding an `@manual` tag.
//!
//! @generated by {COMMIT_HASH}

{INHERITED}
"#;

    const STATE_TEMPLATE: &str = r#"//! Packets for [`{STATE}`](crate::state::{STATE})
//!
//! This file is auto-generated. Disable this by adding an `@manual` tag.
//!
//! @generated by {COMMIT_HASH}
#![expect(missing_docs)]

#[cfg(feature = "bevy")]
use bevy_reflect::prelude::*;
use derive_more::{From, TryInto, TryUnwrap};

{INHERITED}
{GENERATED}
{C2S_REPR}
#[derive(Debug, Clone, PartialEq, From, TryInto, TryUnwrap)]
#[cfg_attr(feature = "bevy", derive(Reflect), reflect(Debug, Clone, PartialEq))]
#[cfg_attr(feature = "io", derive(froglight_macros::FrogPackets))]
pub enum Clientbound{STATE}Packets {
{CLIENTBOUND}}

{S2C_REPR}
#[derive(Debug, Clone, PartialEq, From, TryInto, TryUnwrap)]
#[cfg_attr(feature = "bevy", derive(Reflect), reflect(Debug, Clone, PartialEq))]
#[cfg_attr(feature = "io", derive(froglight_macros::FrogPackets))]
pub enum Serverbound{STATE}Packets {
{SERVERBOUND}}
"#;

    /// Generate a `mod.rs` file for the given state in the specified folder.
    pub(super) async fn generate_state_module(
        current_state: &str,
        codecs: &NetworkCodecs,
        version: &Version,
        deps: &mut DependencyContainer,
        path: &Path,
    ) -> anyhow::Result<()> {
        let state = codecs.get(current_state).unwrap();
        let state_name = current_state.to_case(Case::Pascal);

        // Create the state directory if it does not exist
        if !tokio::fs::try_exists(path).await? {
            tokio::fs::create_dir_all(path).await?;
        }

        let (mut inherit_c2s, mut inherit_s2c) = (HashSet::new(), HashSet::new());
        let inherited = Self::identify_inherited_packets(
            current_state,
            state,
            &mut inherit_c2s,
            &mut inherit_s2c,
            version,
            deps,
        )
        .await?;

        let mut generated = String::new();
        let (mut c2s, mut s2c) = (String::new(), String::new());

        for (id, (name, packet)) in state.c2s.iter().enumerate() {
            let pstruct = super::packet_struct(packet, "c2s");
            c2s.push_str(&format!(
                "    {}({pstruct}) = {id:#04x},\n",
                super::packet_variant(packet)
            ));

            // Skip generating inherited packets
            if !inherit_c2s.contains(name) {
                let pfile = super::packet_file(id, name, "c2s").trim_end_matches(".rs").to_string();
                generated.push_str(&format!("mod {pfile};\npub use {pfile}::{pstruct};\n\n"));

                Self::generate_packet_module(id, name, "c2s", packet, path).await?;
            }
        }
        for (id, (name, packet)) in state.s2c.iter().enumerate() {
            let pstruct = super::packet_struct(packet, "s2c");
            s2c.push_str(&format!(
                "    {}({pstruct}) = {id:#04x},\n",
                super::packet_variant(packet)
            ));

            // Skip generating inherited packets
            if !inherit_s2c.contains(name) {
                let pfile = super::packet_file(id, name, "s2c").trim_end_matches(".rs").to_string();
                generated.push_str(&format!("mod {pfile};\npub use {pfile}::{pstruct};\n\n"));

                Self::generate_packet_module(id, name, "s2c", packet, path).await?;
            }
        }

        let mod_path = path.join("mod.rs");
        // Skip module generation if the file already exists and contains `@manual`
        if let Ok(existing) = tokio::fs::read_to_string(&mod_path).await {
            if existing.contains("@manual @generated") {
                return Ok(());
            }
        }

        // If *all* packets are inherited from the same place,
        // skip generating anything and just re-export the module.
        if inherit_c2s.len() == state.c2s.len()
            && inherit_s2c.len() == state.s2c.len()
            && inherited.chars().filter(|c| *c == '\n').count() == 1
        {
            let base: String = inherited.split_inclusive("::").take(3).collect();
            let inherited = base + "*;";

            let contents = Self::INHERITED_TEMPLATE.replace("{STATE}", &state_name);
            let contents = contents.replace("{INHERITED}", &inherited);

            return super::write_formatted(&contents, &mod_path).await;
        }

        let (mut c2s_repr, mut s2c_repr) = (String::new(), String::new());
        if !state.c2s.is_empty() {
            c2s_repr = String::from("#[repr(u8)]")
        }
        if !state.s2c.is_empty() {
            s2c_repr = String::from("#[repr(u8)]")
        }

        let contents = Self::STATE_TEMPLATE.replace("{STATE}", &state_name);
        let contents = contents.replace("{INHERITED}", &inherited);
        let contents = contents.replace("{GENERATED}", &generated);
        let contents = contents.replace("{C2S_REPR}", &c2s_repr).replace("{S2C_REPR}", &s2c_repr);
        let contents = contents.replace("{CLIENTBOUND}", &c2s).replace("{SERVERBOUND}", &s2c);

        super::write_formatted(&contents, &mod_path).await
    }

    async fn identify_inherited_packets(
        current_state: &str,
        state: &NetworkPackets,
        inherit_c2s: &mut HashSet<String>,
        inherit_s2c: &mut HashSet<String>,
        version: &Version,
        deps: &mut DependencyContainer,
    ) -> anyhow::Result<String> {
        const STATES: &[&str] = &["handshake", "status", "login", "config", "play"];

        let mut versions = deps.get::<ToolConfig>().unwrap().versions.clone();
        let codecs = deps.get_or_retrieve::<VersionCodecs>().await?.clone();

        let manifest = deps.get_or_retrieve::<VersionManifest>().await?;
        versions.sort_unstable_by(|a, b| manifest.compare(a, b).unwrap());

        let mut inherited = String::new();
        for other in versions {
            if manifest.compare(version, &other) == Some(Ordering::Less) {
                continue; // Skip versions that are newer than the current one
            }

            let other_codec = codecs.version(&other).unwrap();

            let skip = (version == &other) as usize;
            let state_index = STATES.iter().position(|s| s == &current_state).unwrap();
            for (later_name, later) in
                STATES.iter().skip(state_index + skip).filter_map(|s| other_codec.get_key_value(*s))
            {
                let mut inherited_packets = Vec::new();

                for (name, packet) in state
                    .c2s
                    .iter()
                    .filter_map(|(_, p1)| later.c2s.iter().find(|(_, p2)| p1 == *p2))
                {
                    if !inherit_c2s.contains(name) {
                        inherited_packets.push(super::packet_struct(packet, "c2s"));
                        inherit_c2s.insert(name.to_string());
                    }
                }

                for (name, packet) in state
                    .s2c
                    .iter()
                    .filter_map(|(_, p1)| later.s2c.iter().find(|(_, p2)| p1 == *p2))
                {
                    if !inherit_s2c.contains(name) {
                        inherited_packets.push(super::packet_struct(packet, "s2c"));
                        inherit_s2c.insert(name.to_string());
                    }
                }

                if !inherited_packets.is_empty() {
                    inherited.push_str(&format!(
                        "pub use crate::{}::{later_name}::{{{}}};\n",
                        format!("v{}", other.to_long_string().replace('.', "_")),
                        inherited_packets.join(", ")
                    ));
                }
            }
        }

        Ok(inherited)
    }
}
