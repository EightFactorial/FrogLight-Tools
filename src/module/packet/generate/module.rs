use std::{cmp::Ordering, collections::HashSet, path::Path};

use convert_case::{Case, Casing};
use froglight_dependency::{
    container::DependencyContainer, dependency::mojang::VersionManifest, version::Version,
};
use tracing::trace;

use crate::{
    module::{
        packet::{
            codecs::{NetworkPackets, PacketInfo},
            NetworkCodecs, VersionCodecs,
        },
        Packets,
    },
    ToolConfig,
};

impl Packets {
    const MODULE_TEMPLATE: &str = r#"//! TODO
//!
//! @generated by {COMMIT_HASH}

#[cfg(feature = "{FEATURE}")]
use froglight_common::version::{VERSION};

#[cfg(feature = "{FEATURE}")]
use crate::state::{Handshake, Status, Login, Config, Play, ValidState};

pub mod config;
pub mod handshake;
pub mod login;
pub mod play;
pub mod status;

#[cfg(feature = "{FEATURE}")]
impl ValidState<Config> for {VERSION} {
    type Clientbound = config::ClientboundConfigPackets;
    type Serverbound = config::ServerboundConfigPackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Handshake> for {VERSION} {
    type Clientbound = handshake::ClientboundHandshakePackets;
    type Serverbound = handshake::ServerboundHandshakePackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Login> for {VERSION} {
    type Clientbound = login::ClientboundLoginPackets;
    type Serverbound = login::ServerboundLoginPackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Play> for {VERSION} {
    type Clientbound = play::ClientboundPlayPackets;
    type Serverbound = play::ServerboundPlayPackets;
}
#[cfg(feature = "{FEATURE}")]
impl ValidState<Status> for {VERSION} {
    type Clientbound = status::ClientboundStatusPackets;
    type Serverbound = status::ServerboundStatusPackets;
}

#[cfg(feature = "{FEATURE}")]
pub mod prelude {
    //! Re-exports of all packet types.

    pub use froglight_common::version::{VERSION};

    pub use super::{handshake::*, play::*, status::*};
}
"#;

    /// Generate a `mod.rs` file for the given version in the specified folder.
    pub(super) async fn generate_version_module(
        version: &Version,
        path: &Path,
    ) -> anyhow::Result<()> {
        let version = format!("V{}", version.to_long_string().replace('.', "_"));
        let feature = version.to_lowercase();

        // Create the directory if it does not exist
        if !tokio::fs::try_exists(&path).await? {
            tokio::fs::create_dir_all(&path).await?;
        }

        // Generate `mod.rs` if it does not exist
        let path = path.join("mod.rs");
        if !tokio::fs::try_exists(&path).await? {
            tracing::debug!("Packets: Generating \"{}\"", path.display());
            let contents = Self::MODULE_TEMPLATE.replace("{VERSION}", &version);
            let contents = contents.replace("{FEATURE}", &feature);

            tokio::fs::write(&path, contents).await?;
        }

        Ok(())
    }

    const STATE_TEMPLATE: &str = r#"//! TODO
#![expect(missing_docs)]

#[cfg(feature = "bevy")]
use bevy_reflect::prelude::*;
use derive_more::{From, TryInto, TryUnwrap};

{INHERITED}
{GENERATED}
{C2S_REPR}
#[derive(Debug, Clone, PartialEq, From, TryInto, TryUnwrap)]
#[cfg_attr(feature = "bevy", derive(Reflect), reflect(Debug, Clone, PartialEq))]
#[cfg_attr(feature = "io", derive(froglight_macros::FrogPackets))]
pub enum Clientbound{STATE}Packets {
{CLIENTBOUND}}

{S2C_REPR}
#[derive(Debug, Clone, PartialEq, From, TryInto, TryUnwrap)]
#[cfg_attr(feature = "bevy", derive(Reflect), reflect(Debug, Clone, PartialEq))]
#[cfg_attr(feature = "io", derive(froglight_macros::FrogPackets))]
pub enum Serverbound{STATE}Packets {
{SERVERBOUND}}
"#;

    /// Generate a `mod.rs` file for the given state in the specified folder.
    pub(super) async fn generate_state_module(
        current_state: &str,
        codecs: &NetworkCodecs,
        version: &Version,
        deps: &mut DependencyContainer,
        path: &Path,
    ) -> anyhow::Result<()> {
        let state = codecs.get(current_state).unwrap();
        let state_name = current_state.to_case(Case::Pascal);

        // Create the state directory if it does not exist
        if !tokio::fs::try_exists(path).await? {
            tokio::fs::create_dir_all(path).await?;
        }

        let mod_path = path.join("mod.rs");
        if tokio::fs::try_exists(&mod_path).await? {
            tracing::debug!("Packets: Skipping \"{}\"", mod_path.display());
            return Ok(());
        }

        let (mut inherit_c2s, mut inherit_s2c) = (HashSet::new(), HashSet::new());
        let inherited = Self::identify_inherited_packets(
            current_state,
            state,
            &mut inherit_c2s,
            &mut inherit_s2c,
            version,
            deps,
        )
        .await?;

        let mut generated = String::new();
        let (mut c2s, mut s2c) = (String::new(), String::new());

        for (id, (name, packet)) in state.c2s.iter().enumerate() {
            let pstruct = packet_struct(packet, "c2s");
            c2s.push_str(&format!("    {}({pstruct}) = {id:#04x},\n", packet_variant(packet)));

            // Skip generating inherited packets
            if !inherit_c2s.contains(name) {
                let pfile = packet_file(id, name, "c2s").trim_end_matches(".rs").to_string();
                generated
                    .push_str(&format!("pub(super) mod {pfile};\npub use {pfile}::{pstruct};\n\n"));

                Self::generate_packet_module(id, name, "c2s", packet, path).await?;
            }
        }
        for (id, (name, packet)) in state.s2c.iter().enumerate() {
            let pstruct = packet_struct(packet, "s2c");
            s2c.push_str(&format!("    {}({pstruct}) = {id:#04x},\n", packet_variant(packet)));

            // Skip generating inherited packets
            if !inherit_s2c.contains(name) {
                let pfile = packet_file(id, name, "s2c").trim_end_matches(".rs").to_string();
                generated
                    .push_str(&format!("pub(super) mod {pfile};\npub use {pfile}::{pstruct};\n\n"));

                Self::generate_packet_module(id, name, "s2c", packet, path).await?;
            }
        }

        let (mut c2s_repr, mut s2c_repr) = (String::new(), String::new());
        if !state.c2s.is_empty() {
            c2s_repr = String::from("#[repr(u8)]")
        }
        if !state.s2c.is_empty() {
            s2c_repr = String::from("#[repr(u8)]")
        }

        let contents = Self::STATE_TEMPLATE.replace("{STATE}", &state_name);
        let contents = contents.replace("{INHERITED}", &inherited);
        let contents = contents.replace("{GENERATED}", &generated);
        let contents = contents.replace("{C2S_REPR}", &c2s_repr).replace("{S2C_REPR}", &s2c_repr);
        let contents = contents.replace("{CLIENTBOUND}", &c2s).replace("{SERVERBOUND}", &s2c);

        tokio::fs::write(&mod_path, contents).await?;

        Ok(())
    }

    async fn identify_inherited_packets(
        current_state: &str,
        state: &NetworkPackets,
        inherit_c2s: &mut HashSet<String>,
        inherit_s2c: &mut HashSet<String>,
        version: &Version,
        deps: &mut DependencyContainer,
    ) -> anyhow::Result<String> {
        const STATES: &[&str] = &["handshake", "status", "login", "config", "play"];

        let mut versions = deps.get::<ToolConfig>().unwrap().versions.clone();
        let codecs = deps.get_or_retrieve::<VersionCodecs>().await?.clone();

        let manifest = deps.get_or_retrieve::<VersionManifest>().await?;
        versions.sort_unstable_by(|a, b| manifest.compare(a, b).unwrap());

        let mut inherited = String::new();
        for other in versions {
            if manifest.compare(version, &other) == Some(Ordering::Less) {
                continue; // Skip versions that are newer than the current one
            }

            let other_codec = codecs.version(&other).unwrap();

            let skip = (version == &other) as usize;
            let state_index = STATES.iter().position(|s| s == &current_state).unwrap();
            for (later_name, later) in
                STATES.iter().skip(state_index + skip).filter_map(|s| other_codec.get_key_value(*s))
            {
                let mut inherited_packets = Vec::new();

                for (name, packet) in state
                    .c2s
                    .iter()
                    .filter_map(|(_, p1)| later.c2s.iter().find(|(_, p2)| p1 == *p2))
                {
                    if !inherit_c2s.contains(name) {
                        inherited_packets.push(packet_struct(packet, "c2s"));
                        inherit_c2s.insert(name.to_string());
                    }
                }

                for (name, packet) in state
                    .s2c
                    .iter()
                    .filter_map(|(_, p1)| later.s2c.iter().find(|(_, p2)| p1 == *p2))
                {
                    if !inherit_s2c.contains(name) {
                        inherited_packets.push(packet_struct(packet, "s2c"));
                        inherit_s2c.insert(name.to_string());
                    }
                }

                if !inherited_packets.is_empty() {
                    inherited.push_str(&format!(
                        "pub use crate::{}::{later_name}::{{{}}};\n",
                        format!("v{}", other.to_long_string().replace('.', "_")),
                        inherited_packets.join(", ")
                    ));
                }
            }
        }

        Ok(inherited)
    }

    const PACKET_TEMPLATE: &str = r#"//! TODO

#[cfg(feature = "bevy")]
use bevy_reflect::prelude::*;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "bevy", derive(Reflect), reflect(Debug, Clone, PartialEq, Hash))]
#[cfg_attr(feature = "io", derive(froglight_macros::FrogBuf))]
pub struct {STRUCT} {}
"#;

    /// Generate a `{name}.rs` file for the given packet.
    pub(super) async fn generate_packet_module(
        id: usize,
        name: &str,
        direction: &str,
        packet: &PacketInfo,
        path: &Path,
    ) -> anyhow::Result<()> {
        let file_name = packet_file(id, name, direction);
        let file_path = path.join(&file_name);

        if tokio::fs::try_exists(&file_path).await? {
            return Ok(());
        }

        let content = Self::PACKET_TEMPLATE.replace("{STRUCT}", &packet_struct(packet, direction));
        tokio::fs::write(file_path, content).await?;

        Ok(())
    }
}

fn packet_variant(packet: &PacketInfo) -> String {
    let mut class = packet.class.split('/').last().unwrap().to_case(Case::Pascal);
    if let Some((head, tail)) = class.split_once('$') {
        let head = head.split_inclusive(char::is_uppercase).take(2).collect::<String>();
        trace!("Packet: Renaming \"{class}\" to ~\"{head}{tail}\"");
        class = head[..head.len().saturating_sub(1)].to_string() + &tail.to_case(Case::Pascal);
    }
    class.replace("S2C", "").replace("C2S", "").trim_end_matches("Packet").to_string()
}

fn packet_struct(packet: &PacketInfo, direction: &str) -> String {
    packet_variant(packet) + &direction.to_uppercase() + "Packet"
}

fn packet_file(id: usize, packet: &str, direction: &str) -> String {
    format!("{direction}_{id:#04x}_{}.rs", packet.trim_start_matches("minecraft:"))
}
