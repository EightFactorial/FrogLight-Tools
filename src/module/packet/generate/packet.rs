use std::path::Path;

use convert_case::{Case, Casing};
use tracing::error;

use crate::module::{
    Packets,
    packet::codecs::{PacketField, PacketInfo},
};

impl Packets {
    const PACKET_FILE_TEMPLATE: &str = r#"//! This file is auto-generated. Disable this by adding an `@manual` tag.
//!
//! @generated by {COMMIT_HASH}

#[cfg(feature = "bevy")]
use bevy_reflect::prelude::*;

{STRUCT}
"#;

    const DEFAULT_DERIVES: &[&str] = &["Debug", "Copy", "Clone", "PartialEq", "Eq", "Hash"];

    /// Generate a `{name}.rs` file for the given packet.
    pub(super) async fn generate_packet_module(
        id: usize,
        name: &str,
        direction: &str,
        packet: &PacketInfo,
        path: &Path,
    ) -> anyhow::Result<()> {
        let file_name = super::packet_file(id, name, direction);
        let file_path = path.join(&file_name);

        // Skip packet generation if the file already exists and contains `@manual`
        if let Ok(existing) = tokio::fs::read_to_string(&file_path).await {
            if existing.contains("@manual @generated") {
                return Ok(());
            }
        }

        let mut derives = Self::DEFAULT_DERIVES.to_vec();
        for (_, ty) in packet.fields_recursive() {
            match ty {
                PacketField::Float | PacketField::Double => {
                    derives.retain(|ty| !matches!(*ty, "Eq" | "Hash"))
                }
                PacketField::String | PacketField::Identifier => {
                    derives.retain(|ty| !matches!(*ty, "Copy"))
                }
                PacketField::Nbt => derives.retain(|ty| !matches!(*ty, "Copy" | "Eq" | "Hash")),
                PacketField::Vec(..) => derives.retain(|ty| !matches!(*ty, "Copy")),
                PacketField::Map(..) => derives.retain(|ty| !matches!(*ty, "Copy" | "Hash")),
                _ => {}
            }
        }
        let derives = format!(
            "#[derive({})]\n#[cfg_attr(feature = \"bevy\", derive(Reflect), reflect(Debug, Clone, PartialEq))]\n#[cfg_attr(feature = \"io\", derive(froglight_macros::FrogBuf))]",
            derives.join(", ")
        );

        let ident = super::packet_ident(packet, direction);
        let mut imports = String::new();
        let mut fields = String::new();

        for (name, ty) in packet.fields() {
            // Fix any invalid field names
            let name = match name.as_ref() {
                "type" => "ty",
                other => other,
            }
            .to_case(Case::Snake);

            let (import, mut attr, ty) = ty.print_field();
            // Properly format the import, if one exists
            if !import.is_empty() {
                imports.push_str(&format!("use {import};\n"));
            }
            // Properly format the field attribute, if one exists
            if !attr.is_empty() {
                attr = format!("#[cfg_attr(feature = \"io\", frog({attr}))]\n    ");
            }

            fields.push_str(&format!("    {attr}pub {name}: {ty},\n"));
        }

        let contents = match packet.fields.len() {
            0 => Self::PACKET_FILE_TEMPLATE
                .replace("{STRUCT}", &format!("{imports}\n{derives}\npub struct {ident};")),
            _ => Self::PACKET_FILE_TEMPLATE.replace(
                "{STRUCT}",
                &format!("{imports}\n{derives}\npub struct {ident} {{\n{fields}}}"),
            ),
        };

        tokio::spawn(async move {
            if let Err(err) = super::write_formatted(&contents, &file_path).await {
                error!("Packets: Failed to generate packet -> {err}");
            }
        });

        Ok(())
    }
}
