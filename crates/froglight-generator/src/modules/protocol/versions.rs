use std::path::Path;

use proc_macro2::TokenStream;
use syn::{File, Item};

use crate::modules::util::{module_name, struct_name, DataBundle, GIT_HASH};

#[allow(clippy::unused_async)]
pub(super) async fn generate(path: &Path, data: &DataBundle) -> anyhow::Result<()> {
    create_versions_mod(path, data)?;
    create_versions_modules(path, data)
}

/// Generate a `mod.rs` file in `src/versions` that re-exports all
/// version-specific modules.
fn create_versions_mod(path: &Path, data: &DataBundle) -> anyhow::Result<()> {
    let mut mod_path = path.join("versions");
    mod_path.push("mod.rs");

    // Create the module doc comment
    let doc = format!(
        "Versions and version-dependent structs and enums\n\n@generated by `froglight-generator #{}`",
        GIT_HASH
    );
    let attrs = vec![syn::parse_quote!(#![doc = #doc])];

    // Generate the use modules
    let mut items = vec![Item::Verbatim(TokenStream::default())];

    for v in &data.config.versions {
        let module_name = module_name(&v.version);
        items.push(syn::parse_quote!(pub mod #module_name;));
    }

    // Write the file
    let output = prettyplease::unparse(&File { shebang: None, attrs, items });
    std::fs::write(mod_path, output)?;

    Ok(())
}

/// Generate a `src/versions/{VERSION}/mod.rs` file for each version.
fn create_versions_modules(path: &Path, data: &DataBundle) -> anyhow::Result<()> {
    let mod_path = path.join("versions");

    for version in &data.config.versions {
        let module_name = module_name(&version.version);
        let struct_name = struct_name(&version.version);
        let protocol = version.protocol;

        // Create the directory
        let mut mod_path = mod_path.join(&module_name.to_string());
        if !mod_path.exists() {
            std::fs::create_dir(&mod_path)?;
        }

        // TODO: Create states and packet modules
        // super::states::generate(&mod_path, &version, data)?;

        // Create the mod.rs file
        mod_path.push("mod.rs");

        // Create doc comments
        let mod_doc = if version.version == version.jar_version {
            format!(
                "Protocol {}\n\nUsed by Minecraft {}\n\n@generated by `froglight-generator #{}`",
                protocol, version.version, GIT_HASH
            )
        } else {
            format!(
                "Protocol {}\n\nUsed by Minecraft {} - {}\n\n@generated by `froglight-generator #{}`",
                protocol, version.version, version.jar_version, GIT_HASH
            )
        };
        let struct_doc = if version.version == version.jar_version {
            format!("Protocol {}\n\nUsed by Minecraft {}", protocol, version.version)
        } else {
            format!(
                "Protocol {}\n\nUsed by Minecraft {} - {}",
                protocol, version.version, version.jar_version
            )
        };

        // Generate the file
        let file = File {
            shebang: None,
            attrs: vec![syn::parse_quote!(#![doc = #mod_doc])],
            items: vec![
                Item::Verbatim(TokenStream::default()),
                // Imports
                syn::parse_quote!(
                    use bevy_reflect::Reflect;
                ),
                syn::parse_quote!(
                    use crate::traits::Version;
                ),
                Item::Verbatim(TokenStream::default()),
                // Version struct
                syn::parse_quote!(
                    #[doc = #struct_doc]
                    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, Reflect)]
                    pub struct #struct_name;
                ),
                // Version trait impl
                syn::parse_quote!(
                    impl Version for #struct_name {
                        const PROTOCOL_VERSION: i32 = #protocol;
                    }
                ),
            ],
        };

        // Write the file
        let output = prettyplease::unparse(&file);
        std::fs::write(mod_path, output)?;
    }

    Ok(())
}
