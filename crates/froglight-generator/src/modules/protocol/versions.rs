use std::path::Path;

use hashbrown::HashMap;
use proc_macro2::{Ident, Span, TokenStream};
use syn::{parse_quote, File, Item};
use tracing::info;

use super::structures::ProtocolState;
use crate::{
    config::SupportedVersion,
    modules::util::{struct_name, write_formatted, DataBundle, GIT_HASH},
};

pub(super) fn generate(
    version: &SupportedVersion,
    path: &Path,
    bundle: &DataBundle,
) -> anyhow::Result<()> {
    // Store `pub mod {STATE};` items for the `mod.rs`
    let mut state_modules = Vec::new();

    // Get a list of states
    let Some((_, data)) = bundle.version_data.get(&version.base_version) else {
        anyhow::bail!("No data found for version {}", version.base_version);
    };

    let protocol = data["version"]["protocol_version"].as_i64().unwrap();
    let protocol = i32::try_from(protocol).unwrap();

    let states: HashMap<String, ProtocolState> =
        serde_json::from_value(data["protocol"]["states"].clone())?;

    // Generate `version/{VERSION}/{STATE}` modules
    for (name, state) in states {
        let name = name.to_lowercase();

        let path = path.join(&name);
        let ident = Ident::new(&name, Span::call_site());

        // Create the {STATE} directory
        if !path.exists() {
            std::fs::create_dir_all(&path)?;
        }

        // Add an import to the `mod.rs`
        state_modules.push(parse_quote!(pub mod #ident;));

        // Generate the module
        super::states::generate(&name, &state, version, &path, bundle)?;
    }

    let path = path.join("mod.rs");
    if path.exists() {
        // Trim the path to the last two directories
        let path = path.display().to_string();
        let count = path.chars().filter(|c| *c == '/').count();
        let trimmed = path.split('/').skip(count - 2).collect::<Vec<&str>>().join("/");
        info!("Skipping `{trimmed}` as it already exists");
        return Ok(());
    }

    // Generate `version/{VERSION}/mod.rs`
    //

    // Create the documentation for the mod.rs file
    let mut mod_doc = if version.base_version == version.jar_version {
        MOD_DOC_SINGLE.replace("{VERSION}", &version.base_version.to_string())
    } else {
        MOD_DOC_RANGE
            .replace("{MIN_VERSION}", &version.base_version.to_string())
            .replace("{MAX_VERSION}", &version.jar_version.to_string())
    }
    .replace("{PROTOCOL}", &protocol.to_string());
    mod_doc.push_str(&format!("{GIT_HASH}`"));

    // Import required items
    let mut module_items = vec![
        Item::Verbatim(TokenStream::new()),
        parse_quote!(
            use crate::traits::Version;
        ),
        Item::Verbatim(TokenStream::new()),
    ];

    // Add the state modules
    module_items.append(&mut state_modules);

    // Create the version struct docs
    let struct_doc = if version.base_version == version.jar_version {
        STRUCT_DOC_SINGLE.replace("{VERSION}", &version.base_version.to_string())
    } else {
        STRUCT_DOC_RANGE
            .replace("{MIN_VERSION}", &version.base_version.to_string())
            .replace("{MAX_VERSION}", &version.jar_version.to_string())
    }
    .replace("{PROTOCOL}", &protocol.to_string());

    module_items.push(Item::Verbatim(TokenStream::new()));

    // Create the version struct
    let struct_ident = struct_name(&version.base_version);
    module_items.push(parse_quote!(
        #[doc = #struct_doc]
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
        #[cfg_attr(feature = "reflect", derive(bevy_reflect::Reflect))]
        pub struct #struct_ident;
    ));

    module_items.push(Item::Verbatim(TokenStream::new()));

    // Implement the Version trait
    module_items.push(parse_quote!(
        impl Version for #struct_ident {
            const PROTOCOL_VERSION: i32 = #protocol;
        }
    ));

    // Write the mod.rs file
    write_formatted(
        &File {
            shebang: None,
            attrs: vec![syn::parse_quote!(#![doc = #mod_doc])],
            items: module_items,
        },
        &path,
        bundle,
    )
}

/// Documentation for the mod.rs file
///
/// Used when the protocol covers a single version
const MOD_DOC_SINGLE: &str = r"Protocol {PROTOCOL}

Used by Minecraft {VERSION}

@generated by `froglight-generator #";

/// Documentation for the mod.rs file
///
/// Used when the protocol covers a range of versions
const MOD_DOC_RANGE: &str = r"Protocol {PROTOCOL}

Used by Minecraft {MIN_VERSION} - {MAX_VERSION}

@generated by `froglight-generator #";

/// Documentation for the Version Struct
///
/// Used when the protocol covers a single version
const STRUCT_DOC_SINGLE: &str = r"Protocol {PROTOCOL}

Used by Minecraft {VERSION}";

/// Documentation for the Version Struct
///
/// Used when the protocol covers a range of versions
const STRUCT_DOC_RANGE: &str = r"Protocol {PROTOCOL}

Used by Minecraft {MIN_VERSION} - {MAX_VERSION}";
