use std::path::Path;

use convert_case::{Case, Casing};
use proc_macro2::{Ident, Span, TokenStream};
use syn::{parse_quote, File, Item};
use tracing::info;

use super::structures::ProtocolState;
use crate::{
    config::SupportedVersion,
    modules::util::{struct_name, write_formatted, DataBundle, GIT_HASH},
};

pub(super) fn generate(
    name: &str,
    state: &ProtocolState,
    version: &SupportedVersion,
    path: &Path,
    bundle: &DataBundle,
) -> anyhow::Result<()> {
    let state_name = name.to_case(Case::Pascal);
    let _state_ident = Ident::new(&state_name, Span::call_site());
    let _version_ident = struct_name(&version.base_version);

    // Store `mod {PACKET};` and `pub use {PACKET}::{PACKET};`
    // items for the `mod.rs`
    let mut packet_modules = Vec::new();

    // Generate `version/{VERSION}/{STATE}/{PACKET}.rs` modules
    generate_packet_files(&state.clientbound, &mut packet_modules, path, bundle)?;
    generate_packet_files(&state.serverbound, &mut packet_modules, path, bundle)?;

    let path = path.join("mod.rs");
    if path.exists() {
        // Trim the path to the last three directories
        let path = path.display().to_string();
        let count = path.chars().filter(|c| *c == '/').count();
        let trimmed = path.split('/').skip(count - 3).collect::<Vec<&str>>().join("/");
        info!("Skipping `{trimmed}` as it already exists");
        return Ok(());
    }

    // Generate `version/{VERSION}/{STATE}/mod.rs`
    //

    let mut module_items = vec![
        Item::Verbatim(TokenStream::new()),
        // parse_quote!(
        //     use crate::{traits::State, states::#state_ident};
        // ),
        // parse_quote!(
        //     use super::#version_ident;
        // ),
        Item::Verbatim(TokenStream::new()),
    ];
    module_items.append(&mut packet_modules);

    // Get the PacketEnum names
    let _clientbound_ident = Ident::new(&format!("{}Clientbound", state_name), Span::call_site());
    let _serverbound_ident = Ident::new(&format!("{}Serverbound", state_name), Span::call_site());

    // Implement the `State<{VERSION}>` trait for {STATE}
    // module_items.push(parse_quote!(
    //     impl State<#version_ident> for #state_ident {
    //         type ClientboundPacket = #clientbound_ident;
    //         type ServerboundPacket = #serverbound_ident;
    //     }
    // ));

    // Generate PacketEnums
    // generate_enum(&clientbound_ident, &state.clientbound, &mut module_items);
    // generate_enum(&serverbound_ident, &state.serverbound, &mut module_items);

    // Get the documentation for the mod.rs file
    let mut mod_doc = MOD_DOC
        .replace("{STATE}", &state_name)
        .replace("{VERSION}", &version.base_version.to_string());
    mod_doc.push_str(&format!("{GIT_HASH}`"));

    // Write the mod.rs file
    write_formatted(
        &File {
            shebang: None,
            attrs: vec![parse_quote!(#![doc = #mod_doc]), parse_quote!(#![allow(missing_docs)])],
            items: module_items,
        },
        &path,
        bundle,
    )
}

/// Generate the packet files for a state
///
/// Moved to a function for deduplication
fn generate_packet_files(
    packets: &[String],
    packet_modules: &mut Vec<Item>,
    path: &Path,
    bundle: &DataBundle,
) -> anyhow::Result<()> {
    for packet in packets {
        // Get the packet name and module name
        let packet_name = packet.split('/').last().unwrap().replace('$', "");
        let mut packet_file_name = packet_name.to_lowercase();
        let packet_mod = Ident::new(&packet_file_name, Span::call_site());

        // Generate the packet file
        packet_file_name.push_str(".rs");
        super::packets::generate(&packet_name, &path.join(&packet_file_name), bundle)?;

        // Add modules and imports to the `mod.rs`
        packet_modules.push(parse_quote!(mod #packet_mod;));
        packet_modules.push(parse_quote!(
            pub use #packet_mod::*;
        ));
        packet_modules.push(Item::Verbatim(TokenStream::new()));
    }

    Ok(())
}

// fn generate_enum(ident: &Ident, packets: &[String], module_items: &mut
// Vec<Item>) {}

const MOD_DOC: &str = r"[`{STATE}`] state packets for [`{VERSION}`]

@generated by `froglight-generator #";
