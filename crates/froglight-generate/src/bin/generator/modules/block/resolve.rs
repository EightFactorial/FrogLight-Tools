use convert_case::{Case, Casing};
use froglight_generate::{CliArgs, DataMap};
use froglight_parse::{file::VersionBlocks, Version};

pub(super) async fn generate_resolve(datamap: &DataMap, args: &CliArgs) -> anyhow::Result<()> {
    for (version, data) in &datamap.version_data {
        generate_resolve_version(version, &data.blocks, args).await?;
    }

    Ok(())
}

async fn generate_resolve_version(
    version: &Version,
    blocks: &VersionBlocks,
    args: &CliArgs,
) -> anyhow::Result<()> {
    let version_name = format!("V{}", version.to_long_string().replace(['.'], "_"));
    let module_name = version_name.to_ascii_lowercase();

    let mut registrations = String::new();
    for block in blocks.iter() {
        let block_name = block.name.replace(['\''], "_").to_case(Case::Pascal);
        let resource_key = block.name.as_str();

        registrations.push_str(&format!(
            "    \"minecraft:{resource_key}\" => |s, id|  s.get_known_block::<{block_name}>(id).map(Into::into),\n",
        ));
    }

    let content = format!(
        r"//! [`BlockResolver`] [`{version_name}`] for [`VanillaResolver`].
//!
//! @generated by 'TODO'
#![allow(clippy::wildcard_imports)]

use froglight_protocol::versions::{module_name}::{version_name};
use phf::phf_map;

use super::{{BlockResolver, VanillaResolver}};
use crate::{{block::*, BlockStorage}};

impl BlockResolver<{version_name}> for VanillaResolver {{
    type Output = Option<Blocks>;
    fn resolve(block_id: u32, storage: &BlockStorage<{version_name}>) -> Self::Output {{
        storage
            .get_stored_default(block_id)
            .and_then(|dyn_block| BLOCKS.get(dyn_block.resource_key()))
            .and_then(|func| func(storage, block_id))
    }}
}}

type BlockFn = fn(&BlockStorage<{version_name}>, u32) -> Option<Blocks>;
static BLOCKS: phf::Map<&'static str, BlockFn> = phf_map! {{
{registrations}}};
"
    );

    // Write the output to a file.
    let file_path = args
        .dir
        .join("crates/froglight-block/src/traits/resolve/")
        .join(format!("{module_name}.rs"));

    if !file_path.exists() {
        tracing::warn!("BlockGenerator: Creating file \"{}\"", file_path.display());
        tokio::fs::create_dir_all(file_path.parent().unwrap()).await?;
    }
    tokio::fs::write(file_path, &content).await?;

    Ok(())
}
