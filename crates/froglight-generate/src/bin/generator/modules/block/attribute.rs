use froglight_generate::{BlockGenerator, CliArgs, DataMap};
use hashbrown::HashMap;
use syn::File;

pub(super) async fn generate_attributes(
    datamap: &DataMap,
    args: &CliArgs,
) -> anyhow::Result<Vec<(String, String)>> {
    // Collect all attributes across all versions.
    let mut attribute_set = HashMap::new();
    for data in datamap.version_data.values() {
        attribute_set.extend(BlockGenerator::attribute_list(&data.blocks));
    }

    // Sort the attributes by name.
    let mut attribute_list: Vec<_> = attribute_set.into_iter().collect();
    attribute_list.sort_by(|(a, _), (b, _)| a.cmp(b));

    // Generate the file output
    let (mut content, modified) = {
        let (items, modified) = BlockGenerator::generate_attributes(&attribute_list);
        let file = File { shebang: None, attrs: Vec::new(), items };
        (prettyplease::unparse(&file), modified)
    };
    // Indent all lines by 4 spaces.
    content = content.lines().map(|line| format!("    {line}")).collect::<Vec<_>>().join("\n");
    // Wrap the content in a macro
    content = format!(
        r"//! Generated attributes for all
//! [`Versions`](froglight_protocol::traits::Version).
//!
//! @generated by 'TODO'
#![allow(missing_docs, non_camel_case_types)]

froglight_macros::impl_generated_attributes! {{
{content}
}}
"
    );

    // Write the output to a file.
    let attrib_path = args.dir.join("crates/froglight-block/src/generated/attribute.rs");
    if !attrib_path.exists() {
        tracing::warn!("BlockGenerator: Creating file \"{}\"", attrib_path.display());
        tokio::fs::create_dir_all(attrib_path.parent().unwrap()).await?;
    }
    tokio::fs::write(attrib_path, &content).await?;

    Ok(modified)
}
