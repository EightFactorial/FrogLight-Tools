use convert_case::{Case, Casing};
use froglight_generate::{CliArgs, DataMap};
use hashbrown::HashMap;

use super::metadata::{MetadataAction, METADATA_ACTIONS};

/// A list of metadata tags that are *not* required.
const REQUIRED_FILTER: &[&str] = &[
    "arrow_count",
    "custom_name_visible",
    "custom_name",
    "hurtdir",
    "interested",
    "pose",
    "sleeping_pos",
    "stinger_count",
    "swell_dir",
];

pub(super) async fn generate_entities(datamap: &DataMap, args: &CliArgs) -> anyhow::Result<()> {
    // Sort the versions using the manifest.
    let mut versions: Vec<_> = datamap.version_data.keys().collect();
    versions.sort_by(|a, b| datamap.manifest.compare(a, b).unwrap());

    // Collect the latest data for all entities.
    let mut entities = HashMap::new();
    for data in datamap.version_data.values() {
        for entity in data.entities.iter() {
            entities.insert(&entity.name, entity);
        }
    }

    // Sort the entities by name.
    let mut entities = entities.into_iter().collect::<Vec<_>>();
    entities.sort_by(|a, b| a.0.cmp(b.0));

    let mut entity_content = String::new();

    // Get the latest specification for each entity.
    for (index, (_, entity)) in entities.iter().enumerate() {
        let ident = entity.name.to_case(Case::Pascal);
        entity_content.push_str(&format!("    {ident} => {{ "));

        let mob_category = entity.category.to_case(Case::Pascal);
        entity_content.push_str(&mob_category);
        entity_content.push_str(", ");

        let mob_type = entity.kind.to_case(Case::Pascal);
        entity_content.push_str(&mob_type);
        entity_content.push_str("Entity, ");

        entity_content.push_str(&format!("EntitySize({}f32,{}f32), ", entity.width, entity.height));

        let filtered: Vec<_> =
            entity.metadata.iter().filter(|&m| !REQUIRED_FILTER.contains(&m.as_str())).collect();
        for (index, metadata) in filtered.iter().enumerate() {
            if let Some((_, MetadataAction::NameAndType(ident, _))) =
                METADATA_ACTIONS.iter().find(|(key, _)| key == metadata)
            {
                entity_content.push_str(ident);
            } else {
                entity_content.push_str(&metadata.to_case(Case::Pascal));
            };

            if index < filtered.len() - 1 {
                entity_content.push_str(", ");
            }
        }

        if index < entities.len() - 1 {
            entity_content.push_str(" },\n");
        } else {
            entity_content.push_str(" }");
        }
    }

    let content = format!(
        r#"//! Generated entities for all versions.
//!
//! @generated by 'TODO'
#[allow(clippy::wildcard_imports, clippy::unreadable_literal)]
use bevy_ecs::component::Component;
#[cfg(feature = "reflect")]
use bevy_ecs::reflect::ReflectComponent;
#[cfg(feature = "reflect")]
use bevy_reflect::{{std_traits::ReflectDefault, Reflect}};

use super::component::*;
use crate::EntitySize;

froglight_macros::impl_generated_entities! {{
{entity_content}
}}
"#
    );

    let file_path = args.dir.join("crates/froglight-entity/src/generated/entity.rs");
    if !file_path.exists() {
        tracing::warn!("EntityGenerator: Creating file \"{}\"", file_path.display());
        tokio::fs::create_dir_all(file_path.parent().unwrap()).await?;
    }
    tokio::fs::write(file_path, &content).await?;

    Ok(())
}
