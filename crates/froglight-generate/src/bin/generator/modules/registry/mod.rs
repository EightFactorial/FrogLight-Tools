use convert_case::{Case, Casing};
use froglight_generate::{CliArgs, DataMap, RegistryGenerator};
use froglight_parse::{file::generator::report::{RegistryReport, RegistryReportEntries}, Version};
use hashbrown::HashMap;

use super::ModuleGenerator;

impl ModuleGenerator for RegistryGenerator {
    /// Generate packets from the given [`DataMap`].
    async fn generate(datamap: &DataMap, args: &CliArgs) -> anyhow::Result<()> {
        generate_all_registries(datamap, args).await?;

        for (version, data) in &datamap.version_data {
            generate_registry_impls(version, &data.generated.reports.registries, args).await?;
        }

        Ok(())
    }
}

async fn generate_all_registries(datamap: &DataMap, args: &CliArgs) -> anyhow::Result<()> {
    // Combine all registry reports into one.
    let mut all_registries: HashMap<&str, RegistryReportEntries> = HashMap::new();
    for data in datamap.version_data.values() {
        for (reg_name, reg_data) in data.generated.reports.registries.iter() {
            if let Some(entry) = all_registries.get_mut(reg_name.as_str()) {
                entry.entries.extend(reg_data.entries.clone());
            } else {
                all_registries.insert(reg_name.as_str(), reg_data.clone());
            }
        }
    }

    let mut content = String::from(
r"//! Generated registries for all 
//! [`Versions`](froglight_protocol::traits::Version).
//!
//! @generated by 'TODO'
#![allow(missing_docs)]

use froglight_macros::FrogRegistry;

");

    // Generate the registry content.
    let mut all_registries: Vec<_> = all_registries.into_iter().collect();
    all_registries.sort_by(|a, b| a.0.cmp(b.0));
    for (reg_name, reg_data) in all_registries {
        // Collect and sort the registry entries by protocol ID.
        let mut reg_variants: Vec<_> = reg_data.entries.into_iter().collect();
        reg_variants.sort_by(|a, b| a.0.cmp(&b.0));

        // Generate the enum content.
        let mut enum_content = String::new();
        for (entry_name, _entry_data) in reg_variants {
            let entry_ident = entry_name
                .trim_start_matches("minecraft:")
                .replace(['.', ':', '/', '\\'], "_")
                .to_case(Case::Pascal);

            // Mark the entry as the default, if it is.
            if reg_data.default.as_ref().is_some_and(|n| n == entry_name) {
                enum_content.push_str(&format!("    #[default]\n    #[frog(key = \"{entry_name}\")]\n    {entry_ident},\n"));
            } else {
                enum_content.push_str(&format!("    #[frog(key = \"{entry_name}\")]\n    {entry_ident},\n"));
            }

        }

        let reg_ident = reg_name
            .trim_start_matches("minecraft:")
            .replace(['.', ':', '/', '\\'], "_")
            .to_case(Case::Pascal);

        // Push the registry enum.
        if reg_data.default.is_some() {
            content.push_str(&format!("#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, FrogRegistry)]\npub enum {reg_ident}Registry {{\n{enum_content}\n}}\n"));
        } else {
            content.push_str(&format!("#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, FrogRegistry)]\npub enum {reg_ident}Registry {{\n{enum_content}\n}}\n"));
        }
    }

    let file_path = args.dir.join("crates/froglight-registry/src/generated/registry.rs");
    if !file_path.exists() {
        tracing::warn!("RegistryGenerator: Creating file \"{}\"", file_path.display());
        tokio::fs::create_dir_all(file_path.parent().unwrap()).await?;
    }
    tokio::fs::write(file_path, &content).await?;

    Ok(())
}

async fn generate_registry_impls(version: &Version, report: &RegistryReport, args: &CliArgs) -> anyhow::Result<()> {
    let version_name = format!("V{}", version.to_long_string().replace(['.'], "_"));
    let module_name = version_name.to_ascii_lowercase();

    let mut report: Vec<_> = report.iter().collect();
    report.sort_by(|a, b| a.0.cmp(b.0));

    let mut impl_content = String::new();
    for (reg_name, reg_data) in report {
        let reg_ident = reg_name
            .trim_start_matches("minecraft:")
            .replace(['.', ':', '/', '\\'], "_")
            .to_case(Case::Pascal);

        impl_content.push_str(&format!("        {reg_ident}Registry {{ "));

        let mut entries: Vec<_> = reg_data.entries.iter().collect();
        entries.sort_by(|a, b| a.1.protocol_id.cmp(&b.1.protocol_id));
        for (index, (entry_name, _entry_data)) in entries.iter().enumerate() {
            let entry_ident = entry_name
                .trim_start_matches("minecraft:")
                .replace(['.', ':', '/', '\\'], "_")
                .to_case(Case::Pascal);

            // Push the registry impl.
            impl_content.push_str(&entry_ident);
            if index < entries.len() - 1 {
                impl_content.push_str(", ");
            }
        }

        impl_content.push_str(" },\n");
    }

        let content = format!(
r"//! Generated registry impls for [`{version_name}`].
//!
//! @generated by 'TODO'
#![allow(clippy::wildcard_imports)]

use froglight_protocol::versions::{module_name}::{version_name};

use super::registry::*;
use crate::{{RegistryId, RegistryKey}};

froglight_macros::impl_generated_registries! {{
    {version_name} => {{
{impl_content}    }}
}}
");

    let file_path = args.dir.join("crates/froglight-registry/src/generated/").join(format!("{module_name}.rs"));
    if !file_path.exists() {
        tracing::warn!("RegistryGenerator: Creating file \"{}\"", file_path.display());
        tokio::fs::create_dir_all(file_path.parent().unwrap()).await?;
    }
    tokio::fs::write(file_path, &content).await?;

    Ok(())
}